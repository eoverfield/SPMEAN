/**
 * Module dependencies.
 */
var passport = require('passport')
  , url = require('url')
  , https = require('https')
  , util = require('util')
  , utils = require('./utils')
  , jwt = require('jwt-simple')
  , OAuth2 = require('oauth').OAuth2
  , InternalOAuthError = require('./internaloautherror');;


var SP_AUTH_PREFIX = '/_layouts/15/OAuthAuthorize.aspx';
var SP_REDIRECT_PREFIX = '/_layouts/15/appredirect.aspx';

/**
 * `Strategy` constructor.
 *
 * @param {Object} options
 * @param {Function} verify
 * @api public
 */
function Strategy(options, verify) {
	options = options || {}
	passport.Strategy.call(this);
	this.name = 'sharepoint';
	this._verify = verify;

	this._appId = options.appId;
	this._appSecret = options.appSecret;
	//this._callbackURL = options.callbackURL; //a callback isn't needed, strategy is loaded when SP redirects to NodeJS app
	this._scope = options.scope;
	this._scopeSeparator = options.scopeSeparator || ' ';
	this._passReqToCallback = options.passReqToCallback;
	this._skipUserProfile = (options.skipUserProfile === undefined) ? false : options.skipUserProfile;

	//console.log('SP strategy being created');
}

/**
 * Inherit from `passport.Strategy`.
 */
util.inherits(Strategy, passport.Strategy);


/**
 * Authenticate request by delegating to the SharePoint OAuth 2.0 provider.
 *
 * @param {Object} req
 * @api protected
 */
Strategy.prototype.authenticate = function(req, options) {
	options = options || {};
	var self = this;

	if (req != undefined && req.query && req.query.error) {
		// TODO: Error information pertaining to OAuth 2.0 flows is encoded in the
		//       query parameters, and should be propagated to the application.
		return this.fail();
	}

	//display the current url that is being loaded in NodeJS
	//console.log('orig url: ' + req.originalUrl);

	var spLanguage = options.spLanguage;

	var spAppToken = undefined;
	var spSiteUrl = undefined;
	  
	// load token and SP Calling site url from request
	if (req != undefined && req.body && req.body.SPAppToken)
		spAppToken = req.body.SPAppToken;
	if(req != undefined && req.body && req.body.SPSiteUrl)
		spSiteUrl = req.query.SPSiteUrl;

	//The current spSiteUrl, will likely have to get from querystring below
	//console.log('SiteUrl from post: ' + spSiteUrl);
	//console.log('req.query.SPHostUrl: ' + req.query.SPHostUrl);

	if(spSiteUrl == undefined && req != undefined && req.query && req.query.SPHostUrl)
		spSiteUrl = req.query.SPHostUrl;
	
	//display the current SP CAling url. We used the query string var as a fallback
	//console.log('SiteUrl from post: ' + spSiteUrl);

	//fallback to optional values.
	if (spAppToken == undefined)
		spAppToken = options.spAppToken;
	if(spSiteUrl == undefined)
		spSiteUrl = options.spSiteUrl;

	//display the apptoken and sp site url with what we will use moving forward.
	//console.log('App Token from post request from SP: ' + spAppToken);
	//console.log('SP Site Url from Post request or querystring: ' + spSiteUrl);
  
	// you can pass the appId and Secret in every round
	if (options.appId)
		this._appId = options.appId; //should have been set in /config/env/..., i.e. /config/env/secure.js
	if (options.appSecret)
		this._appSecret = options.appSecret; //should have been set in /config/env/..., i.e. /config/env/secure.js

	if (!this._appId) throw new Error('SharePointStrategy requires a appId.');
	if (!this._appSecret) throw new Error('SharePointStrategy requires a appSecret.');
  
	//console.log('SP App ID: ' + this._appId);
	//console.log('SP App Secret ' + this._appSecret);

	var authorizationURL = spSiteUrl + SP_AUTH_PREFIX; //SP_AUTH_PREIX Set above
	var appRedirectURL = spSiteUrl + SP_REDIRECT_PREFIX; //SP_REDIRECT_PREFIX Set above
  
	//console.log('SP AUTH URL: ' + authorizationURL);
	//console.log('SP Redirect URL: ' + appRedirectURL);
  
	// check if there is a app token and sp site url. If there is then we can assume that visitor came here from SP and we can attempt to get them
	// an accessToken and refreshToken. If spAppToken was not provided then we will need to handle somehow.
	if (spAppToken && spSiteUrl) {
		//console.log('SPAppToken and SPSiteUrl exist');
	
		//get actual token values from decoded spAppToken
		var token = eval(jwt.decode(spAppToken, '', true));
		var splitApptxSender = token.appctxsender.split("@");
		var sharepointServer = url.parse(spSiteUrl)
		var resource = splitApptxSender[0]+"/"+sharepointServer.host+"@"+splitApptxSender[1];
		var spappId = this._appId+"@"+splitApptxSender[1];
		var appctx = JSON.parse(token.appctx);
		var tokenServiceUri = url.parse(appctx.SecurityTokenServiceUri);
		var tokenURL = tokenServiceUri.protocol+'//'+tokenServiceUri.host+'/'+splitApptxSender[1]+tokenServiceUri.path;
	
		//console.log('Set up OAuth2 vars needed for request');
		//console.log('SPAppId - formatted: ' + spappId);
		//console.log('_appSecret: ' + this._appSecret);
		//console.log('authorizationURL: ' + authorizationURL);
		//console.log('tokenURL: ' + tokenURL);

		//set up oAuth2 var
		this._oauth2 = new OAuth2(spappId,  this._appSecret, '', authorizationURL, tokenURL);
		
		//let oauth do its magic. Go to auth url to authorize appToken then go to ACS server to get accessToken for this user
		this._oauth2.getOAuthAccessToken(
			token.refreshtoken,
			{grant_type: 'refresh_token', refresh_token: token.refreshtoken, resource: resource},
			function (err, accessToken, refreshToken, params) {
				//console.log('Get access token complete');
			
				//if an error was returned, then return error response
				//TODO: return detailed response to visitor with action steps
				if (err) {
					//console.log('getOAuthAccessToken error thrown: ' + err);
					return self.error(new InternalOAuthError('failed to obtain access token', err));
				}
				
				//check to see if refreshToken returned. If not, no worries yet, just set it to the original spAppToken for now.
				if (!refreshToken) {
					//console.log('not refresh token');
					refreshToken = spAppToken;
				}
			
				//console.log('Current spAppToken: ' + spAppToken);
				//console.log('Current refreshToken: ' + refreshToken);
				
				//based on our accessToken ACS returned, go and get the user profile. Helps verify accessToken too
				self._loadUserProfile(accessToken, spSiteUrl, function(err, profile) {
					//console.log('Loaded a user profile in SP Strategy');
				
					//if we were unable to load a user profile, then we have a problem. We will assume with token so we must bail.
					// TODO: We do not need to load a user profile, we could use other methods to test accessToken
					if (err) {
						//console.log('Loading user profile error: ' + err);
						//return self.error(err);
						return self.error(new InternalOAuthError('Loading user profile error: ' + err, err));
					};
            
					//used to check if a user is available and no errors
					function verified(err, user, info) {
						if (err) { return self.error(err); }
						if (!user) { return self.fail(info); }
						
						self.success(user, info);
					}

					//set this user's local profile properties
					profile.cacheKey = appctx.CacheKey; //come from decoded spAppToken (token.appctx.CacheKey
					profile.language = spLanguage; //comes from options.spLanguage
              
					//console.log('Will pass to callback? ' + self._passReqToCallback);
			  
					//if the calling function to authenticate wants the original request in the callback.
					if (self._passReqToCallback) {
						//get the number of parameters in callback function
						var arity = self._verify.length;
						
						//console.log('Display post host currently stored in profile: ' + profile.host);
						//console.log('Display post site currently stored in profile: ' + profile.site);
				
						//if there are six parameters then also pass back params, provided to use from getOAuthAccessToken
						if (arity == 6) {
							self._verify(req, accessToken, refreshToken, params, profile, verified);
						} else { // arity == 5
							self._verify(req, accessToken, refreshToken, profile, verified);
						}
					}
					else { /*callback does not need original request in callback*/
						//console.log('Should not pass req to callback);
						
						//get the number of parameters in callback function
						var arity = self._verify.length;
						
						//if there are five parameters then also pass back params, provided to use from getOAuthAccessToken
						if (arity == 5) {
							self._verify(accessToken, refreshToken, params, profile, verified);
						} else { // arity == 4
							self._verify(accessToken, refreshToken, profile, verified);
						}
					}
				});  /* /_loadUserProfile */
			} /* /end complete function from getOAuthAccessToken */
		); /* /getOAuthAccessToken*/ 
	} 
	//if no spAppToken && spSiteUrl, then look in query for "Code" and "tokenURL"
	//could be used for call back from SP, but not used in this implementation, nor fully tested
	else if (req != undefined && req.query && req.query.code && authorizationURL && req.query.tokenURL) {
		//get the oauth var
		this._oauth2 = new OAuth2(this._appId, this._appSecret, '', authorizationURL, req.query.tokenURL);
    
		var code = req.query.code;

		// NOTE: The module oauth (0.9.5), which is a dependency, automatically adds
		//       a 'type=web_server' parameter to the percent-encoded data sent in
		//       the body of the access token request.  This appears to be an
		//       artifact from an earlier draft of OAuth 2.0 (draft 22, as of the
		//       time of this writing).  This parameter is not necessary, but its
		//       presence does not appear to cause any issues.
		
		//go and get the access token
		this._oauth2.getOAuthAccessToken(
			code,
			{ grant_type: 'authorization_code', resource: req.query.resource, redirect_uri: callbackURL },
			function(err, accessToken, refreshToken, params) {

				if (err) {
					return self.error(new InternalOAuthError('failed to obtain access token', err));
				}
			
				//load the user profile if we got a valid accessToken
				self._loadUserProfile(accessToken, function(err, profile) {
					if (err) {
						return self.error(err);
					};
			  
					function verified(err, user, info) {
						if (err) { return self.error(err); }
						if (!user) { return self.fail(info); }
						self.success(user, info);
					}
			  
					//similar as in block above if we had spAppToken && spSiteUrl
					if (self._passReqToCallback) {
						var arity = self._verify.length;
						if (arity == 6) {
							self._verify(req, accessToken, refreshToken, params, profile, verified);
						}
						else { // arity == 5
							self._verify(req, accessToken, refreshToken, profile, verified);
						}
					}
					else {
						var arity = self._verify.length;
						if (arity == 5) {
							self._verify(accessToken, refreshToken, params, profile, verified);
						}
						else { // arity == 4
							self._verify(accessToken, refreshToken, profile, verified);
						}
					}
				}); /* /_loadUserProfile*/
			} /* /end complete function from getOAuthAccessToken */
		); /* /getOAuthAccessToken*/ 
	}
	//if we only have an appRedirectURL, then set up state and create an authorization URL
	//would likely need to redirect back to SP for authentication
	//but not needed and not fully tested
	else if (appRedirectURL) {
		this._oauth2 = new OAuth2(this._appId,  this._appSecret, '', appRedirectURL, '');
    
		var params = this.authorizationParams(options);
		params['response_type'] = 'code';
		params['redirect_uri'] = callbackURL; //callbackURL does not exist
    
		var scope = options.scope || this._scope;
		if (scope) {
			if (Array.isArray(scope)) { scope = scope.join(this._scopeSeparator); }
			params.scope = scope;
		}
		var state = options.state;
		if (state) { params.state = state; }
    
		var location = this._oauth2.getAuthorizeUrl(params);
		this.redirect(location);
	}
	//if we get here, then an invalid accessToken request was provided, so error out
	//TODO: provide a better error to visitor and provide them an action
	else {
		return self.error(new InternalOAuthError('failed to obtain access token')); 
	}
} /* /end authorization for this strategy*/

/**
 * Retrieve user profile from SharePoint. Must already have a valid accessToken from ACS as well as the SPSiteUrl to post against.
 *
 * @param {String} accessToken
 * @param {Function} done
 * @api protected
 */
Strategy.prototype.userProfile = function(accessToken, spSiteUrl, done) {
	//get the SP server in a sharepointServer object that will include different components of spSiteUrl url
	var sharepointServer = {};
	if (spSiteUrl)
		sharepointServer = url.parse(spSiteUrl)
	else
		return done(null, {});
		
	//make sure that path includes trailing /
	if (sharepointServer.path.length > 1)
		sharepointServer.path = sharepointServer.path + '/';
  
	//set up our REST headers that include Accept and our Authorization accessToken
	var headers = {
		'Accept': 'application/json;odata=verbose',
		'Authorization' : 'Bearer ' + accessToken
	};
	//options for our SSL request
	//providing a cipher of RC4 and SSL_OP_NO_TLSv1_2 caused error
	var options = {
		host : sharepointServer.hostname, 
		port : sharepointServer.port || 443,
		path : sharepointServer.path + '_api/web/currentuser', //path to request current user based on accessToken
		method : 'GET',
		headers : headers,
		agent: false,
		//ciphers: 'RC4',
		secureOptions: require('constants').SSL_OP_NO_TLSv1_2
		//secureOptions: require('constants').SSLv3_method
		//secureOptions: require('constants').TLSv1_method
	};
  
	//console.log('Display current strategy host: ' + options.host);
	//console.log('Display current strategy path: ' + options.path);
  
	//set up new SSL request to our SP server with our header to make a valid REST request
	var req = https.get(options, function(res) {
		res.setEncoding('utf8');
		var userData = '';
    
		//when data is received, add to userData
		res.on('data', function(data) {
			userData += data;
		});
    
		//when request is complete, process
		res.on('end', function() {
			//console.log('Strategy get user profile req has ended');
			//console.log('Raw getcurrentuser data: ' + userData);
			
			//userData should be valid json, so parse
			var json = JSON.parse(userData);
			
			//if we have our expected "d" field, then we can continue
			if (json.d) {
				//create a new "profile"
				var profile = { provider: 'sharepoint' };
				profile.id = json.d.Id;
				profile.username = json.d.LoginName;
				profile.displayName = json.d.Title;
				profile.emails = [{ value: json.d.Email }];
				siteUrl = url.parse(spSiteUrl);
				profile.host = siteUrl.protocol + '//' + siteUrl.host;
				profile.site = siteUrl.pathname;
				if (profile.site.length > 1)
					profile.site = profile.site + '/';
				profile._raw = json;
        
				//"profile" is complete from rest request to get current user, so return profile
				//"done" here is the function that will get called by the code that executed "_loadUserProfile"
				//so this will return no error and the profile back to whoever called _loadUserProfile, such as authentication calling function
				done(null, profile);
			}
			//if there was an error when parsing json, then address
			else if (json.error) {
				//console.log('Authentication failed: ' + json.error.code + ' at ' + options.host + ':' + options.port + options.path);
				return done ('Authentication failed: ' + json.error.code + ' at ' + options.host + ':' + options.port + options.path, null);
			}
			else {
				//console.log('Authentication failed: Unknown exception at' + options.host + ':' + options.port + options.path);
				return done('Authentication failed: Unknown exception at' + options.host + ':' + options.port + options.path , null);
			}
		}); /* /end response end function from https request */
	//ending the "get" https call
	}).on('error', function(e) {
		//console.log('Authentication ssl request failed: ' + e + ' at ' + options.host + ':' + options.port + options.path);
		return done('Authentication ssl request failed: ' + e + ' at ' + options.host + ':' + options.port + options.path , null);
	});
}

/**
 * Return extra parameters to be included in the authorization request.
 *
 * @param {Object} options
 * @return {Object}
 * @api protected
 */
Strategy.prototype.authorizationParams = function(options) {
	return {};
}

/**
 * Load user profile, contingent upon options.
 *
 * @param {String} accessToken
 * @param {Function} done
 * @api private
 */
Strategy.prototype._loadUserProfile = function(accessToken, spSiteUrl, done) {
	var self = this;
  
	//will be called if we actually want to load the userprofile
	function loadIt() {
		return self.userProfile(accessToken, spSiteUrl, done);
	}
	//called if we actually want to skip loading the user profile because of 
	function skipIt() {
		return done(null);
	}
  
	//if a skipuserprofile function was provided to strategy options, then attempt to use skip function instead of normal get user profile method
	if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {
		// async
		this._skipUserProfile(accessToken, function(err, skip) {
			if (err) { return done(err); }
			
			//if now told not to skip, likely because the custom skip function failed, then get in normal way
			if (!skip) {
				return loadIt();
			}
			
			//if here, then skip function must have worked.
			return skipIt();
		}); /* /_skipUserProfile*/
	}
	else {
		//check to see if _skipUserProfile was set to true or false instead of function
		var skip = (typeof this._skipUserProfile == 'function') ? this._skipUserProfile() : this._skipUserProfile;
		if (!skip) {
			return loadIt();
		}
		return skipIt();
	}
}


/**
 * Expose `Strategy`.
 */ 
module.exports = Strategy;

